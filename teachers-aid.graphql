### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


enum AcademicOutomeTypes {
  LOGIC_BUILDING
  SCHEMA_BUIDING
  SOCRATIC_QUESTIONS
}

input AddCourseToTeacherInput {
  courseId: ID!
  teacherId: ID!
}

type AddCourseToTeacherPayload {
  teacher: Teacher!
}

input AddNewChapterInput {
  chapterNumber: Int!
  chapterTitle: String!
  textTitle: String!
}

type AddNewChapterPayload {
  chapter: Chapter!
}

input AddNewTextInput {
  ownerId: ID!
  textTitle: String!
}

type AddNewTextPayload {
  text: Text!
}

input AddStudentToCourseInput {
  courseId: ID!
  studentId: ID!
}

type AddStudentToCoursePayload {
  student: Student!
}

input AddVocabWordInput {
  _id: ID!
  definition: String!
  position: Int!
  word: String!
}

type AddVocabWordPayload {
  textSection: TextSection!
}

input AssignEssayInput {
  assignedCourse: String!
  dueDate: Date!
  hasAssigner: String!
  markingPeriod: MarkingPeriodEnum!
  maxPoints: Int!
  readings: ReadingsInput!
  topic: TopicInput!
}

type AssignEssayPayload {
  essay: [Essay!]!
}

interface Assignment {
  _id: ID
  assignedDate: Date!
  dueDate: Date!
  exempt: Boolean!
  hasAssigner: Teacher!
  hasOwner: Student!
  late: Boolean!
  markingPeriod: String!
  readings: Readings!
  score: Score!
}

input ChangeVocabWordInput {
  _id: ID!
  definition: String!
  newDefinition: String!
  newWord: String!
  word: String!
}

type Chapter {
  _id: ID
  chapterNumber: Int!
  chapterTitle: String!
  fromText: Text!
  hasSections: TextSection!
}

type Course {
  _id: ID
  hasStudents: [Student!]!
  hasTeacher: Teacher!
  period: String!
}

input CreateCourseInput {
  period: String!
}

type CreateCoursePayload {
  course: Course!
}

input CreateLessonInput {
  afterActivity: TextSectionProtocolsInput!
  assignedCourse: [ID!]!
  assignedDate: Date!
  assignedMarkingPeriod: MarkingPeriodEnum!
  assignedSections: LessonTextSectionsInput!
  beforeActivity: TextSectionProtocolsInput!
  duringActivities: [TextSectionProtocolsInput!]!
  essentialQuestion: String!
  questionList: [TextSectionQuestionsInput!]!
  vocabList: [TextSectionVocabInput!]!
}

type CreateLessonPayload {
  lessons: [Lesson!]!
}

input CreateTextSectionInput {
  fromChapterId: String!
  hasProtocols: [TextSectionProtocolsInput!]!
  hasQuestions: [TextSectionQuestionsInput!]!
  hasVocab: [TextSectionVocabInput!]!
  header: String!
  pageNumbers: PageNumbersInput!
}

type CreateTextSectionPayload {
  textSection: TextSection!
}

scalar Date

scalar DateTime

type Essay implements Assignment {
  _id: ID
  assignedDate: Date!
  dueDate: Date!
  exempt: Boolean!
  finalDraft: FinalDraftContainer
  hasAssigner: Teacher!
  hasOwner: Student!
  late: Boolean!
  markingPeriod: String!
  readings: Readings!
  score: Score!
  topic: Topic!
  workingDraft: WorkingDraft!
}

type FinalDraftContainer {
  returned: Boolean!
  submitted: Boolean!
  submittedFinalDraft: SubmittedFinalDraft!
  submitTime: DateTime
}

input FindAssignmentsToGradeInput {
  teacherUserName: String!
}

type FindAssignmentsToGradePayload {
  assignments: [Assignment!]!
}

input FindChaptersInTextInput {
  textTitle: String!
}

type FindChaptersInTextPayload {
  chapters: [Chapter!]!
}

input FindChapterTitleInput {
  chapter_id: ID!
}

type FindChapterTitlePayload {
  chapter: Chapter!
}

input FindCourseByIdInput {
  courseId: ID!
}

type FindCourseByIdPayload {
  course: Course!
}

input FindEssayByIdInput {
  _id: ID!
}

type FindEssayByIdPayload {
  essay: Essay!
}

input FindEssaysByUserNameAndMarkingPeriodInput {
  markingPeriod: MarkingPeriodEnum!
  userName: String!
}

type FindEssaysByUserNameAndMarkingPeriodPayload {
  essay: [Essay!]
}

input FindLessonByCourseAndDateInput {
  courseId: ID!
  lessonDate: Date!
}

type FindLessonByCourseAndDatePayload {
  lesson: Lesson!
}

input FindLessonByCourseInput {
  courseId: ID!
}

type FindLessonByCoursePayload {
  lessons: [Lesson!]!
}

input FindLessonByIdInput {
  _id: ID!
}

type FindLessonByIdPayload {
  lesson: Lesson!
}

input FindTextByTitleInput {
  title: String
}

type FindTextByTitlePayload {
  text: Text!
}

input FindTextSectionByIdInput {
  _id: ID!
}

type FindTextSectionByIdPayload {
  textSection: TextSection!
}

input FindTextSectionsByChapterInput {
  fromChapterId: ID!
}

type FindTextSectionsByChapterPayload {
  textSections: [TextSection!]!
}

input FindTextSectionsByIdInput {
  _ids: [ID!]!
}

type FindTextSectionsByIdPayload {
  textSections: [TextSection!]!
}

type FindTextsPayload {
  texts: [Text!]!
}

input FindUserDataInput {
  _id: ID!
}

type FindUserDataPayload {
  user: User!
}

input HasAssigner {
  assignerUserName: String
}

input HasOwnerInput {
  ownerUserName: String
}

type Individual implements Protocol {
  _id: ID
  assignedDate: Date!
  isActive: Boolean!
  student: Student!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type Lesson {
  _id: ID
  afterActivity: TextSectionProtocols!
  assignedCourse: Course!
  assignedDate: Date!
  assignedMarkingPeriod: MarkingPeriodEnum!
  assignedSections: LessonTextSections!
  beforeActivity: TextSectionProtocols!
  duringActivities: [TextSectionProtocols!]!
  essentialQuestion: String!
  objectives: String
  questionList: [TextSectionQuestions!]!
  vocabList: [TextSectionVocab!]!
}

type LessonTextSections {
  endingSection: String!
  startingSection: String!
}

input LessonTextSectionsInput {
  endingSection: String!
  startingSection: String!
}

input LoginInput {
  password: String!
  userName: String!
}

type LoginPayload {
  user: User!
}

enum MarkingPeriodEnum {
  FIRST
  FOURTH
  SECOND
  THIRD
}

type Mutation {
  addCourseToTeacher(input: AddCourseToTeacherInput!): AddCourseToTeacherPayload!
  addNewChapter(input: AddNewChapterInput!): AddNewChapterPayload!
  addNewText(input: AddNewTextInput!): AddNewTextPayload!
  addStudentToCourse(input: AddStudentToCourseInput!): AddStudentToCoursePayload!
  addVocabWord(input: AddVocabWordInput!): AddVocabWordPayload!
  changeVocabWord(input: ChangeVocabWordInput!): UpdateVocabPayload!
  createCourse(input: CreateCourseInput!): CreateCoursePayload!
  createLesson(input: CreateLessonInput!): CreateLessonPayload!
  createTextSection(input: CreateTextSectionInput!): CreateTextSectionPayload!
  login(input: LoginInput!): LoginPayload!
  logout: Boolean!
  registerStudent(input: RegisterStudentInput!): RegisterStudentPayload!
  RegisterTeacher(input: RegisterTeacherInput!): RegisterTeacherPayload!
  removeTextSection(input: RemoveTextSectionInput!): RemoveTextSectionPayload!
  returnGradedEssay(input: ReturnGradedEssayInput!): ReturnGradedEssayPayload!
  submitEssayFinalDraft(input: SubmitEssayFinalDraftInput!): SubmitEssayFinalDraftPayload!
  updateTextSection(input: UpdateTextSectionInput!): UpdateTextSectionPayload!
  updateWorkingDraft(input: UpdateWorkingDraftInput!): UpdateWorkingDraftPayload!
}

type PageNumbers {
  endingPage: Int!
  startingPage: Int!
}

input PageNumbersInput {
  endingPage: Int!
  startingPage: Int!
}

interface Protocol {
  _id: ID
  assignedDate: Date!
  isActive: Boolean!
}

enum ProtocolActivityTypes {
  INDIVIDUAL
  THINK_PAIR_SHARE
}

type Query {
  findAssignmentsToGrade(input: FindAssignmentsToGradeInput!): FindAssignmentsToGradePayload!
  findChaptersInText(input: FindChaptersInTextInput!): FindChaptersInTextPayload!
  findChapterTitle(input: FindChapterTitleInput!): FindChapterTitlePayload!
  findCourseById(input: FindCourseByIdInput!): FindCourseByIdPayload!
  findEssayById(input: FindEssayByIdInput!): FindEssayByIdPayload!
  findEssaysByUserNameAndMarkingPeriod(input: FindEssaysByUserNameAndMarkingPeriodInput!): FindEssaysByUserNameAndMarkingPeriodPayload!
  findLessonByCourse(input: FindLessonByCourseInput!): FindLessonByCoursePayload!
  findLessonByCourseAndDate(input: FindLessonByCourseAndDateInput!): FindLessonByCourseAndDatePayload!
  findLessonById(input: FindLessonByIdInput!): FindLessonByIdPayload!
  findTextByTitle(input: FindTextByTitleInput!): FindTextByTitlePayload!
  findTexts: FindTextsPayload!
  findTextSectionById(input: FindTextSectionByIdInput!): FindTextSectionByIdPayload!
  findTextSectionsByChapter(input: FindTextSectionsByChapterInput!): FindTextSectionsByChapterPayload!
  findTextSectionsById(input: FindTextSectionsByIdInput!): FindTextSectionsByIdPayload!
  findUserData(input: FindUserDataInput!): FindUserDataPayload!
  me: User
}

enum QuestionTypeEnum {
  HOW_CAUSE_EFFECT
  HOW_PROBLEM_SOLUTION
  WHY_CAUSE_EFFECT
}

type Reading_Guide implements Assignment {
  _id: ID
  assignedDate: Date!
  completion: String!
  dueDate: Date!
  exempt: Boolean!
  hasAssigner: Teacher!
  hasOwner: Student!
  late: Boolean!
  markingPeriod: String!
  readings: Readings!
  score: Score!
}

type Readings {
  readingPages: String!
  readingSections: String!
}

input ReadingsInput {
  readingPages: String!
  readingSections: String!
}

input RegisterStudentInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  userName: String!
}

type RegisterStudentPayload {
  student: Student!
}

input RegisterTeacherInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  title: TitleEnum!
  userName: String!
}

type RegisterTeacherPayload {
  teacher: Teacher!
}

input RemoveTextSectionInput {
  _id: ID!
}

type RemoveTextSectionPayload {
  removed: Boolean!
}

input ReturnGradedEssayInput {
  _id: ID!
  comments: [String!]!
  gradedDraft: JSON!
  score: Int!
}

type ReturnGradedEssayPayload {
  essay: Essay!
}

type Score {
  earnedPoints: Int!
  maxPoints: Int!
}

type Student implements User {
  _id: ID
  email: String
  firstName: String!
  hasAssignments: [Assignment!]!
  inCourses: [Course!]!
  lastName: String!
  password: String!
  userName: String!
}

input SubmitEssayFinalDraftInput {
  _id: ID!
  late: Boolean!
  submittedFinalDraft: SubmittedFinalDraftsInput!
}

type SubmitEssayFinalDraftPayload {
  essay: Essay!
}

type SubmittedFinalDraft {
  comments: [String!]!
  draft: JSON!
  gradingDraft: JSON!
  score: Int!
}

input SubmittedFinalDraftsInput {
  comments: [String!]!
  draft: JSON!
  gradingDraft: JSON!
  score: Int!
}

type Teacher implements User {
  _id: ID
  email: String
  firstName: String!
  lastName: String!
  password: String!
  teachesCourses: [Course!]!
  title: TitleEnum!
  userName: String!
}

type Test implements Assignment {
  _id: ID
  assignedDate: Date!
  dueDate: Date!
  exempt: Boolean!
  hasAssigner: Teacher!
  hasOwner: Student!
  late: Boolean!
  markingPeriod: String!
  readings: Readings!
  score: Score!
  testName: String!
}

type Text {
  _id: ID
  hasChapters: [Chapter!]!
  ownerId: ID!
  textTitle: String!
}

input TextChapterInput {
  chapterNumber: Int!
  chapterTitle: String!
}

input TextInput {
  chapters: [String!]!
  textTitle: String!
}

type TextSection {
  _id: ID
  fromChapter: Chapter!
  hasProtocols: [TextSectionProtocols!]!
  hasQuestions: [TextSectionQuestions!]!
  hasVocab: [TextSectionVocab!]!
  header: String!
  pageNumbers: PageNumbers!
}

"""Protocol suggestions for including in a LessonPlan"""
type TextSectionProtocols {
  academicOutcomeTypes: AcademicOutomeTypes!
  activityType: ProtocolActivityTypes!
  task: String!
}

input TextSectionProtocolsInput {
  academicOutcomeTypes: AcademicOutomeTypes!
  activityType: ProtocolActivityTypes!
  task: String!
}

type TextSectionQuestions {
  question: String!
  questionType: QuestionTypeEnum!
}

input TextSectionQuestionsInput {
  question: String!
  questionType: QuestionTypeEnum!
}

type TextSectionVocab {
  definition: String!
  word: String!
}

input TextSectionVocabInput {
  definition: String!
  word: String!
}

type ThinkPairShare implements Protocol {
  _id: ID
  assignedDate: Date!
  hadConversation: Boolean!
  isActive: Boolean!
  studentPair: [Student!]!
}

scalar Time

enum TitleEnum {
  MISS
  MR
  MRS
  MS
}

type Topic {
  question: String!
  questionType: QuestionTypeEnum!
}

input TopicInput {
  question: String!
  questionType: QuestionTypeEnum!
}

input UpdateTextSectionInput {
  _id: ID!
  fromChapterId: String!
  hasProtocols: [TextSectionProtocolsInput!]!
  hasQuestions: [TextSectionQuestionsInput!]!
  hasVocab: [TextSectionVocabInput!]!
  header: String!
  pageNumbers: PageNumbersInput!
}

type UpdateTextSectionPayload {
  textSection: TextSection!
}

type UpdateVocabPayload {
  textSection: TextSection!
}

input UpdateWorkingDraftInput {
  _id: ID!
  updatedDraft: JSON!
}

type UpdateWorkingDraftPayload {
  essay: Essay!
}

interface User {
  _id: ID
  email: String
  firstName: String!
  lastName: String!
  password: String!
  userName: String!
}

type WorkingDraft {
  draft: JSON!
}

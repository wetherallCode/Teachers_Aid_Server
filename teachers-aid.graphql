### This file was generated by Nexus Schema
### Do not make changes to this file directly

type AcademicOrganizer {
  academicSentenceStructure: AcademicSentenceStructure!
  answerType: AnswerTypes
  conclusion: String!
  questionType: QuestionTypeEnum
  restatement: String!
}

enum AcademicOutomeTypes {
  LOGIC_BUILDING
  SCHEMA_BUIDING
  SOCRATIC_QUESTIONS
}

type AcademicSentenceStructure {
  object: String
  subject: String!
  verb: String!
}

input AcademicSentenceStructureInput {
  object: String
  subject: String!
  verb: String!
}

input AddCourseToTeacherInput {
  courseId: ID!
  teacherId: ID!
}

type AddCourseToTeacherPayload {
  teacher: Teacher!
}

input AddNewChapterInput {
  chapterNumber: Int!
  chapterTitle: String!
  textTitle: String!
}

type AddNewChapterPayload {
  chapter: Chapter!
}

input AddNewTextInput {
  ownerId: ID!
  textTitle: String!
}

type AddNewTextPayload {
  text: Text!
}

input AddStudentsToCourseInput {
  courseId: ID!
  studentIds: [ID!]!
}

type AddStudentsToCoursePayload {
  students: [Student!]!
}

input AddVocabWordInput {
  _id: ID!
  definition: String!
  position: Int!
  word: String!
}

type AddVocabWordPayload {
  textSection: TextSection!
}

type AdvancedOrganizer {
  advancedSentenceStructure: AdvancedSentenceStructure!
  answerType: AnswerTypes
  conclusion: String!
  questionType: QuestionTypeEnum
  restatement: String!
}

type AdvancedSentenceStructure {
  object: String
  subject: String!
  verb: String!
}

input AdvancedSentenceStructureInput {
  object: String
  subject: String!
  verb: String!
}

union AnswerTypes =
    HowCauseEffectAnswerType
  | ProblemSolutionAnswerType
  | WhyCauseEffectAnswerType

input AssignEssaysInput {
  assignedDate: Date!
  dueDate: Date!
  section: String!
  studentIds: [ID!]!
}

type AssignEssaysPayload {
  essays: [Essay!]!
}

interface Assignment {
  _id: ID
  assigned: Boolean!
  assignedDate: Date!
  associatedLessonId: ID!
  dueDate: Date!
  dueTime: String!
  exempt: Boolean!
  hasAssigner: Teacher!
  hasOwner: Student!
  late: Boolean!
  markingPeriod: MarkingPeriodEnum!
  readings: Readings!
  score: Score!
}

enum BasicQuestionEnum {
  HOW
  WHY
}

input ChangeVocabWordInput {
  _id: ID!
  definition: String!
  newDefinition: String!
  newWord: String!
  word: String!
}

type Chapter {
  _id: ID
  chapterNumber: Int!
  chapterTitle: String!
  fromText: Text!
  hasSections: TextSection!
}

type ComprehensionMetrics implements ProgressMetrics {
  _id: ID
  comprehensionLevel: Int!
  student: Student!
}

type ContactInfo {
  guardianEmail: String!
  guardianFirstName: String!
  guardianLastName: String!
  guardianPhone: String!
}

type Course {
  _id: ID
  courseType: CourseTypeEnum!
  hasLessons: [Lesson!]!
  hasStudents: [Student!]!
  hasTeacher: Teacher!
  name: String!
}

input CourseInput {
  _id: ID!
  name: String
}

enum CourseTypeEnum {
  ENGLISH_LANGUAGE_ARTS
  MATH
  RELATED_ARTS
  SCIENCE
  SOCIAL_STUDIES
}

input CreateAbsenceInput {
  dayAbsent: Date!
  markingPeriod: MarkingPeriodEnum!
  studentId: String!
}

type CreateAbsencePayload {
  studentAbsence: StudentAbsence!
}

input CreateCourseInput {
  courseType: CourseTypeEnum!
  name: String!
}

type CreateCoursePayload {
  course: Course!
}

input CreateEssayInput {
  assignedCourseId: [ID!]!
  assignedDate: Date!
  associatedLessonId: ID!
  dueDate: Date!
  dueTime: String!
  hasAssignerId: String!
  markingPeriod: MarkingPeriodEnum!
  maxPoints: Int!
  readings: ReadingsInput!
  topicList: [TopicInput!]!
}

type CreateEssayPayload {
  essays: [Essay!]!
}

input CreateExcusedLatenessInput {
  dayLateExcused: Date!
  markingPeriod: MarkingPeriodEnum!
  studentId: ID!
}

type CreateExcusedLatenessPayload {
  excusedLateness: ExcusedLateness!
}

input CreateLessonInput {
  afterActivity: TextSectionProtocolsInput!
  assignedCourses: [ID!]!
  assignedDate: Date!
  assignedMarkingPeriod: MarkingPeriodEnum!
  assignedSectionIdList: [ID!]!
  assignedSections: LessonTextSectionsInput!
  beforeActivity: TextSectionProtocolsInput!
  duringActivities: [TextSectionProtocolsInput!]!
  essentialQuestion: String!
  inUnit: ID!
  lessonName: String!
  pageNumbers: PageNumbersInput!
  questionList: [TextSectionQuestionsInput!]!
  vocabList: [TextSectionVocabInput!]!
}

type CreateLessonPayload {
  lessons: [Lesson!]!
}

input CreateResponsibilityPointsInput {
  markingPeriod: MarkingPeriodEnum!
  studentIds: [ID!]!
}

type CreateResponsibilityPointsPayload {
  responsibilityPoints: [ResponsibilityPoints!]!
}

input CreateRubricEntryInput {
  entry: String!
  rubricCategories: [WritingLevelEnum!]!
  rubricSection: RubricSectionEnum!
  score: Int!
}

type CreateRubricEntryPayload {
  rubricEntry: RubricEntry!
}

input CreateTextSectionInput {
  fromChapterId: String!
  hasProtocols: [TextSectionProtocolsInput!]!
  hasQuestions: [TextSectionQuestionsInput!]!
  hasVocab: [TextSectionVocabInput!]!
  header: String!
  pageNumbers: PageNumbersInput!
}

type CreateTextSectionPayload {
  textSection: TextSection!
}

input CreateUnexcusedLatenessInput {
  dayLate: Date!
  markingPeriod: MarkingPeriodEnum!
  studentId: ID!
}

type CreateUnexcusedLatenessPayload {
  unexcusedLateness: UnexcusedLateness!
}

input CreateUnitInput {
  unitName: String!
}

type CreateUnitPayload {
  unit: Unit!
}

scalar Date

scalar DateTime

type DevelopingOrganizer {
  answer: String!
  basicQuestionType: BasicQuestionEnum
  conclusion: String!
  developingSentenceStructure: DevelopingSentenceStructure!
  restatement: String!
}

input DevelopingOrganizerInput {
  answer: String!
  conclusion: String!
  questionType: String!
  restatement: String!
  sentenceStructure: String!
}

type DevelopingSentenceStructure {
  subject: String!
  verb: String!
}

input DevelopingSentenceStructureInput {
  subject: String!
  verb: String!
}

type Essay implements Assignment {
  _id: ID
  assigned: Boolean!
  assignedDate: Date!
  associatedLessonId: ID!
  dueDate: Date!
  dueTime: String!
  exempt: Boolean!
  finalDraft: FinalDraftContainer
  hasAssigner: Teacher!
  hasOwner: Student!
  late: Boolean!
  markingPeriod: MarkingPeriodEnum!
  readings: Readings!
  score: Score!
  topic: Topic!
  workingDraft: WorkingDraft!
}

type ExcusedLateness {
  _id: ID
  dayLateExcused: Date!
  markingPeriod: MarkingPeriodEnum!
  student: Student!
}

type FinalDraftContainer {
  returned: Boolean!
  submitted: Boolean!
  submittedFinalDraft: SubmittedFinalDraft!
  submitTime: DateTime
}

input FindAssignmentsToGradeInput {
  teacherUserName: String!
}

type FindAssignmentsToGradePayload {
  assignments: [Assignment!]!
}

input FindChaptersInTextInput {
  textTitle: String!
}

type FindChaptersInTextPayload {
  chapters: [Chapter!]!
}

input FindChapterTitleInput {
  chapter_id: ID!
}

type FindChapterTitlePayload {
  chapter: Chapter!
}

input FindCourseByIdInput {
  courseId: ID!
}

type FindCourseByIdPayload {
  course: Course!
}

input FindCoursesByIdInput {
  _ids: [ID!]!
}

type FindCoursesByIdPayload {
  courses: [Course!]!
}

input FindCurrentMarkingPeriodInput {
  _id: ID!
}

type FindCurrentMarkingPeriodPayload {
  markingPeriod: MarkingPeriod!
}

input FindEssayByIdInput {
  _id: ID!
}

type FindEssayByIdPayload {
  essay: Essay!
}

input FindEssaysByUserNameAndMarkingPeriodInput {
  markingPeriod: MarkingPeriodEnum!
  userName: String!
}

type FindEssaysByUserNameAndMarkingPeriodPayload {
  essay: [Essay!]
}

input FindEssaysToCompleteByStudentIdInput {
  studentId: ID!
}

type FindEssaysToCompleteByStudentIdPayload {
  essays: [Essay!]!
}

input FindEssaysToGradeByIdInput {
  teacherId: ID!
}

type FindEssaysToGradeByIdPayload {
  essays: [Essay!]!
}

input FindLessonByCourseAndDateInput {
  courseId: ID!
  lessonDate: Date!
}

type FindLessonByCourseAndDatePayload {
  lesson: Lesson!
}

input FindLessonByCourseInput {
  courseId: ID!
}

type FindLessonByCoursePayload {
  lessons: [Lesson!]!
}

input FindLessonByIdInput {
  _id: ID!
}

type FindLessonByIdPayload {
  lesson: Lesson!
}

input FindLessonsByUnitInput {
  courseId: ID!
  unitId: ID!
}

type FindLessonsByUnitPayload {
  lessons: [Lesson!]!
}

input FindRubricEntriesByCategoryInput {
  rubricCategory: WritingLevelEnum!
}

type FindRubricEntriesByCategoryPayload {
  rubricEntries: [RubricEntry!]!
}

type FindRubricEntriesPayload {
  rubricEntries: [RubricEntry!]!
}

input FindStudentsByIdInput {
  studentIds: [ID!]!
}

type FindStudentsByIdPayload {
  students: [Student!]!
}

input FindTextByTitleInput {
  title: String
}

type FindTextByTitlePayload {
  text: Text!
}

input FindTextSectionByIdInput {
  _id: ID!
}

type FindTextSectionByIdPayload {
  textSection: TextSection!
}

input FindTextSectionsByChapterInput {
  fromChapterId: ID!
}

type FindTextSectionsByChapterPayload {
  textSections: [TextSection!]!
}

input FindTextSectionsByIdInput {
  _ids: [ID!]!
}

type FindTextSectionsByIdPayload {
  textSections: [TextSection!]!
}

type FindTextsPayload {
  texts: [Text!]!
}

type FindUnitsPayload {
  units: [Unit!]!
}

input FindUserDataInput {
  _id: ID!
}

type FindUserDataPayload {
  user: User!
}

input HasAssigner {
  assignerUserName: String
}

input HasOwnerInput {
  ownerUserName: String
}

type HowCauseEffectAnswerType {
  after: String!
  before: String!
  cause: String!
}

type HowCauseEffectMetrics {
  howCauseEffectLevel: WritingLevelEnum!
  levelPoints: Int!
}

type HowProblemSolutionMetrics {
  howProblemSolutionLevel: WritingLevelEnum!
  levelPoints: Int!
}

type Individual implements Protocol {
  _id: ID
  assignedDate: Date!
  isActive: Boolean!
  student: Student!
}

input InitializeStudentsInput {
  markingPeriod: MarkingPeriodEnum!
  studentIds: [ID!]!
}

type InitializeStudentsPayload {
  students: [Student!]!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON
type Lesson {
  _id: ID
  afterActivity: TextSectionProtocols!
  assignedCourse: Course!
  assignedDate: Date!
  assignedMarkingPeriod: MarkingPeriodEnum!
  assignedSectionIdList: [ID!]!
  assignedSections: LessonTextSections!
  beforeActivity: TextSectionProtocols!
  duringActivities: [TextSectionProtocols!]!
  essentialQuestion: String!
  inUnit: Unit!
  lessonName: String!
  linkedCourseIds: [ID!]!
  objectives: String
  pageNumbers: PageNumbers!
  questionList: [TextSectionQuestions!]!
  vocabList: [TextSectionVocab!]!
}

type LessonTextSections {
  endingSection: String!
  startingSection: String!
}

input LessonTextSectionsInput {
  endingSection: String!
  startingSection: String!
}

input LoginInput {
  password: String!
  userName: String!
}

type LoginPayload {
  user: User!
}

type MarkingPeriod {
  _id: ID
  currentMarkingPeriod: MarkingPeriodEnum!
}

enum MarkingPeriodEnum {
  FIRST
  FOURTH
  SECOND
  THIRD
}

type Mutation {
  addCourseToTeacher(
    input: AddCourseToTeacherInput!
  ): AddCourseToTeacherPayload!
  addNewChapter(input: AddNewChapterInput!): AddNewChapterPayload!
  addNewText(input: AddNewTextInput!): AddNewTextPayload!
  addStudentsToCourse(
    input: AddStudentsToCourseInput!
  ): AddStudentsToCoursePayload!
  addVocabWord(input: AddVocabWordInput!): AddVocabWordPayload!
  assignEssays(input: AssignEssaysInput!): AssignEssaysPayload!
  changeVocabWord(input: ChangeVocabWordInput!): UpdateVocabPayload!
  createAbsence(input: CreateAbsenceInput!): CreateAbsencePayload!
  createCourse(input: CreateCourseInput!): CreateCoursePayload!
  createEssay(input: CreateEssayInput!): CreateEssayPayload!
  createExcusedLateness(
    input: CreateExcusedLatenessInput!
  ): CreateExcusedLatenessPayload!
  createLesson(input: CreateLessonInput!): CreateLessonPayload!
  createResponsibilityPoints(
    input: CreateResponsibilityPointsInput!
  ): CreateResponsibilityPointsPayload!
  createRubricEntry(input: CreateRubricEntryInput!): CreateRubricEntryPayload!
  createTextSection(input: CreateTextSectionInput!): CreateTextSectionPayload!
  createUnexcusedLateness(
    input: CreateUnexcusedLatenessInput!
  ): CreateUnexcusedLatenessPayload!
  createUnit(input: CreateUnitInput!): CreateUnitPayload!
  initializeStudents(
    input: InitializeStudentsInput!
  ): InitializeStudentsPayload!
  login(input: LoginInput!): LoginPayload!
  logout: Boolean!
  registerStudent(input: RegisterStudentInput!): RegisterStudentPayload!
  RegisterTeacher(input: RegisterTeacherInput!): RegisterTeacherPayload!
  removeAbsence(input: RemoveAbsenceInput!): RemoveAbsencePayload!
  removeLateness(input: RemoveLatenessInput!): RemoveLatenessPayload!
  removeRubricEntry(input: RemoveRubricEntryInput!): RemoveRubricEntryPayload!
  removeStudentsFromCourse(
    input: RemoveStudentsFromCourseInput!
  ): RemoveStudentsFromCoursePayload!
  removeTextSection(input: RemoveTextSectionInput!): RemoveTextSectionPayload!
  returnGradedEssay(input: ReturnGradedEssayInput!): ReturnGradedEssayPayload!
  setAnswerType(input: SetAnswerTypeInput!): SetAnswerTypePayload!
  setCurrentMarkingPeriod(
    input: SetCurrentMarkingPeriodInput!
  ): SetCurrentMarkingPeriodPayload!
  setOrganizer(input: SetOrganizerInput!): SetOrganizerPayload!
  submitEssayFinalDraft(
    input: SubmitEssayFinalDraftInput!
  ): SubmitEssayFinalDraftPayload!
  unAssignEssays(input: UnAssignEssaysInput!): UnAssignEssaysPayload!
  updateAcademicOrganizer(
    input: UpdateAcademicOrganizerInput!
  ): UpdateAcademicOrganizerPayload!
  updateAdvancedOrganizer(
    input: UpdateAdvancedOrganizerInput!
  ): UpdateAdvancedOrganizerPayload!
  updateDevelopingOrganizer(
    input: UpdateDevelopingOrganizerInput!
  ): UpdateDevelopingOrganizerPayload!

  """
  To change an individual students topic question information or dueDate
  """
  updateEssayByStudent(
    input: UpdateEssayByStudentInput!
  ): UpdateEssayByStudentPayload!

  """
  only useful for changing marking period
  """
  updateEssaysByLesson(
    input: UpdateEssaysByLessonInput!
  ): UpdateEssaysByLessonPayload!
  updateEssaysByQuestion(
    input: UpdateEssaysByQuestionInput!
  ): UpdateEssaysByQuestionPayload!

  """
  For updating an assignment for an entire course(s)
  """
  updateEssaysByStudentsAndSection(
    input: UpdateEssaysByStudentsAndSectionInput!
  ): UpdateEssaysByStudentsAndSectionPayload!
  updateHowCauseEffect(
    input: UpdateHowCauseEffectInput!
  ): UpdateHowCauseEffectPayload!
  updateLesson(input: UpdateLessonInput!): UpdateLessonPayload!
  updateProblemSolution(
    input: UpdateProblemSolutionInput!
  ): UpdateProblemSolutionPayload!
  updateResponsibilityPoints(
    input: UpdateResponsibilityPointsInput!
  ): UpdateResponsibilityPointsPayload!
  updateRubricEntry(input: UpdateRubricEntryInput!): UpdateRubricEntryPayload!
  updateTextSection(input: UpdateTextSectionInput!): UpdateTextSectionPayload!
  updateWhyCauseEffect(
    input: UpdateWhyCauseEffectInput!
  ): UpdateWhyCauseEffectPayload!
  updateWorkingDraft(
    input: UpdateWorkingDraftInput!
  ): UpdateWorkingDraftPayload!
}

union Organizers = AcademicOrganizer | AdvancedOrganizer | DevelopingOrganizer

type OverallWritingMetric {
  levelPoints: Int!
  overallWritingLevel: WritingLevelEnum!
}

type PageNumbers {
  endingPage: Int!
  startingPage: Int!
}

input PageNumbersInput {
  endingPage: Int!
  startingPage: Int!
}

type ProblemSolutionAnswerType {
  problem: String!
  reasonForProblem: String!
  solvedBy: String!
  whySolutionSolved: String!
}

interface ProgressMetrics {
  _id: ID
  student: Student!
}

interface Protocol {
  _id: ID
  assignedDate: Date!
  isActive: Boolean!
}

enum ProtocolActivityTypes {
  INDIVIDUAL
  THINK_PAIR_SHARE
}

type Query {
  findAssignmentsToGrade(
    input: FindAssignmentsToGradeInput!
  ): FindAssignmentsToGradePayload!
  findChaptersInText(
    input: FindChaptersInTextInput!
  ): FindChaptersInTextPayload!
  findChapterTitle(input: FindChapterTitleInput!): FindChapterTitlePayload!
  findCourseById(input: FindCourseByIdInput!): FindCourseByIdPayload!
  findCoursesById(input: FindCoursesByIdInput!): FindCoursesByIdPayload!
  findCurrentMarkingPeriod: FindCurrentMarkingPeriodPayload!
  findEssayById(input: FindEssayByIdInput!): FindEssayByIdPayload!
  findEssaysByUserNameAndMarkingPeriod(
    input: FindEssaysByUserNameAndMarkingPeriodInput!
  ): FindEssaysByUserNameAndMarkingPeriodPayload!
  findEssaysToCompleteByStudentId(
    input: FindEssaysToCompleteByStudentIdInput!
  ): FindEssaysToCompleteByStudentIdPayload!
  findEssaysToGradeById(
    input: FindEssaysToGradeByIdInput!
  ): FindEssaysToGradeByIdPayload!
  findLessonByCourse(
    input: FindLessonByCourseInput!
  ): FindLessonByCoursePayload!
  findLessonByCourseAndDate(
    input: FindLessonByCourseAndDateInput!
  ): FindLessonByCourseAndDatePayload!
  findLessonById(input: FindLessonByIdInput!): FindLessonByIdPayload!
  findLessonsByUnit(input: FindLessonsByUnitInput!): FindLessonsByUnitPayload!
  findRubricEntries: FindRubricEntriesPayload!
  findRubricEntriesByCategory(
    input: FindRubricEntriesByCategoryInput!
  ): FindRubricEntriesByCategoryPayload!
  findStudentsById(input: FindStudentsByIdInput!): FindStudentsByIdPayload!
  findTextByTitle(input: FindTextByTitleInput!): FindTextByTitlePayload!
  findTexts: FindTextsPayload!
  findTextSectionById(
    input: FindTextSectionByIdInput!
  ): FindTextSectionByIdPayload!
  findTextSectionsByChapter(
    input: FindTextSectionsByChapterInput!
  ): FindTextSectionsByChapterPayload!
  findTextSectionsById(
    input: FindTextSectionsByIdInput!
  ): FindTextSectionsByIdPayload!
  findUnits: FindUnitsPayload!
  findUserData(input: FindUserDataInput!): FindUserDataPayload!
  me: User
}

enum QuestionTypeEnum {
  HOW_CAUSE_EFFECT
  HOW_PROBLEM_SOLUTION
  WHY_CAUSE_EFFECT
}

type Reading_Guide implements Assignment {
  _id: ID
  assigned: Boolean!
  assignedDate: Date!
  associatedLessonId: ID!
  completion: String!
  dueDate: Date!
  dueTime: String!
  exempt: Boolean!
  hasAssigner: Teacher!
  hasOwner: Student!
  late: Boolean!
  markingPeriod: MarkingPeriodEnum!
  readings: Readings!
  score: Score!
}

type Readings {
  readingPages: String!
  readingSections: String!
}

input ReadingsInput {
  readingPages: String!
  readingSections: String!
}

input RegisterStudentInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  userName: String!
}

type RegisterStudentPayload {
  student: Student!
}

input RegisterTeacherInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  title: TitleEnum!
  userName: String!
}

type RegisterTeacherPayload {
  teacher: Teacher!
}

input RemoveAbsenceInput {
  _id: ID!
}

type RemoveAbsencePayload {
  removed: Boolean!
}

input RemoveLatenessInput {
  _id: ID!
}

type RemoveLatenessPayload {
  removed: Boolean!
}

input RemoveRubricEntryInput {
  rubricEntryId: ID!
}

type RemoveRubricEntryPayload {
  removed: Boolean!
}

input RemoveStudentsFromCourseInput {
  courseId: ID!
  studentIds: [ID!]!
}

type RemoveStudentsFromCoursePayload {
  students: [Student!]!
}

input RemoveTextSectionInput {
  _id: ID!
}

type RemoveTextSectionPayload {
  removed: Boolean!
}

type ResponsibilityPoints {
  _id: ID
  markingPeriod: MarkingPeriodEnum!
  responsibilityPoints: Int!
  student: Student!
}

input ReturnGradedEssayInput {
  _id: ID!
  comments: [String!]!
  gradedDraft: JSON!
  score: Int!
}

type ReturnGradedEssayPayload {
  essay: Essay!
}

type RubricEntry {
  _id: ID
  entry: String!
  rubricCategories: [WritingLevelEnum!]!
  rubricSection: RubricSectionEnum!
  score: Int!
}

enum RubricSectionEnum {
  ANSWER
  CONCLUSION
  GENERAL
  OVERALL
  TOPIC
}

type Score {
  earnedPoints: Int!
  maxPoints: Int!
}

input SetAnswerTypeInput {
  essayId: ID!
  questionType: QuestionTypeEnum!
}

type SetAnswerTypePayload {
  essay: Essay!
}

input SetCurrentMarkingPeriodInput {
  currentMarkingPeriod: MarkingPeriodEnum!
}

type SetCurrentMarkingPeriodPayload {
  markingPeriod: MarkingPeriod!
}

input SetOrganizerInput {
  essayId: ID!
  writingLevel: WritingLevelEnum!
}

type SetOrganizerPayload {
  essay: Essay!
}

type Student implements User {
  _id: ID
  email: String
  firstName: String!
  hasAbsences: [StudentAbsence!]!
  hasAssignments: [Assignment!]!
  hasContactInformation: StudentInformation!
  hasExcusedLatenesses: [ExcusedLateness!]!
  hasResponsibilityPoints: [ResponsibilityPoints!]!
  hasUnExcusedLatenesses: [UnexcusedLateness!]!
  hasWritingMetrics: WritingMetrics!
  inCourses: [Course!]!
  lastName: String!
  password: String!
  userName: String!
}

type StudentAbsence {
  _id: ID
  dayAbsent: Date!
  markingPeriod: MarkingPeriodEnum!
  student: Student!
}

type StudentInformation {
  _id: ID
  contactInfo: [ContactInfo!]!
  student: Student!
}

input SubmitEssayFinalDraftInput {
  _id: ID!
  late: Boolean!
  submittedFinalDraft: SubmittedFinalDraftsInput!
}

type SubmitEssayFinalDraftPayload {
  essay: Essay!
}

type SubmittedFinalDraft {
  comments: [String!]!
  draft: JSON!
  gradingDraft: JSON!
  score: Int!
}

input SubmittedFinalDraftsInput {
  comments: [String!]!
  draft: JSON!
  gradingDraft: JSON!
  score: Int!
}

type Teacher implements User {
  _id: ID
  email: String
  firstName: String!
  lastName: String!
  password: String!
  teachesCourses: [Course!]!
  title: TitleEnum!
  userName: String!
}

type Test implements Assignment {
  _id: ID
  assigned: Boolean!
  assignedDate: Date!
  associatedLessonId: ID!
  dueDate: Date!
  dueTime: String!
  exempt: Boolean!
  hasAssigner: Teacher!
  hasOwner: Student!
  late: Boolean!
  markingPeriod: MarkingPeriodEnum!
  readings: Readings!
  score: Score!
  testName: String!
}

type Text {
  _id: ID
  hasChapters: [Chapter!]!
  ownerId: ID!
  textTitle: String!
}

input TextChapterInput {
  chapterNumber: Int!
  chapterTitle: String!
}

input TextInput {
  chapters: [String!]!
  textTitle: String!
}

type TextSection {
  _id: ID
  fromChapter: Chapter!
  hasProtocols: [TextSectionProtocols!]!
  hasQuestions: [TextSectionQuestions!]!
  hasVocab: [TextSectionVocab!]!
  header: String!
  pageNumbers: PageNumbers!
}

"""
Protocol suggestions for including in a LessonPlan
"""
type TextSectionProtocols {
  academicOutcomeTypes: AcademicOutomeTypes!
  activityType: ProtocolActivityTypes!
  task: String!
}

input TextSectionProtocolsInput {
  academicOutcomeTypes: AcademicOutomeTypes!
  activityType: ProtocolActivityTypes!
  task: String!
}

type TextSectionQuestions {
  question: String!
  questionType: QuestionTypeEnum!
}

input TextSectionQuestionsInput {
  question: String!
  questionType: QuestionTypeEnum!
}

type TextSectionVocab {
  definition: String!
  word: String!
}

input TextSectionVocabInput {
  definition: String!
  word: String!
}

type ThinkPairShare implements Protocol {
  _id: ID
  assignedDate: Date!
  hadConversation: Boolean!
  isActive: Boolean!
  studentPair: [Student!]!
}

scalar Time

enum TitleEnum {
  MISS
  MR
  MRS
  MS
}

type Topic {
  question: String!
  questionType: QuestionTypeEnum!
  writingLevel: WritingLevelEnum!
}

input TopicInput {
  question: String!
  questionType: QuestionTypeEnum!
  writingLevel: WritingLevelEnum!
}

input TopicTypeInput {
  writingLevel: WritingLevelEnum
}

input UnAssignEssaysInput {
  section: String!
  studentIds: [ID!]!
}

type UnAssignEssaysPayload {
  essays: [Essay!]!
}

type UnexcusedLateness {
  _id: ID
  dayLate: Date!
  markingPeriod: MarkingPeriodEnum!
  student: Student!
}

type Unit {
  _id: ID
  hasLessons: [Lesson!]!
  unitName: String!
}

input UnitInput {
  _id: ID!
  unitName: String!
}

input UpdateAcademicOrganizerInput {
  academicSentenceStructure: AcademicSentenceStructureInput!
  conclusion: String!
  essayId: ID!
  restatement: String!
}

type UpdateAcademicOrganizerPayload {
  essay: Essay!
}

input UpdateAdvancedOrganizerInput {
  advancedSentenceStructure: AdvancedSentenceStructureInput!
  conclusion: String!
  essayId: ID!
  restatement: String!
}

type UpdateAdvancedOrganizerPayload {
  essay: Essay!
}

input UpdateDevelopingOrganizerInput {
  answer: String!
  basicQuestionType: BasicQuestionEnum!
  conclusion: String!
  developingSentenceStructure: DevelopingSentenceStructureInput!
  essayId: ID!
  restatement: String!
}

type UpdateDevelopingOrganizerPayload {
  essay: Essay!
}

input UpdateEssayByStudentInput {
  dueDate: Date!
  section: String!
  studentId: ID!
  topic: TopicInput
}

type UpdateEssayByStudentPayload {
  essay: Essay!
}

input UpdateEssaysByLessonInput {
  lessonId: ID!
  markingPeriod: MarkingPeriodEnum!
}

type UpdateEssaysByLessonPayload {
  essays: [Essay!]!
}

input UpdateEssaysByQuestionInput {
  newQuestion: String!
  newQuestionType: QuestionTypeEnum!
  newWritingLevel: WritingLevelEnum!
  originalQuestion: String!
}

type UpdateEssaysByQuestionPayload {
  essays: [Essay!]!
}

input UpdateEssaysByStudentsAndSectionInput {
  assignedDate: Date!
  dueDate: Date!
  dueTime: String!
  markingPeriod: MarkingPeriodEnum
  maxPoints: Int!
  section: String!
  studentId: [ID!]!
}

type UpdateEssaysByStudentsAndSectionPayload {
  essays: [Essay!]!
}

input UpdateHowCauseEffectInput {
  after: String!
  before: String!
  cause: String!
  essayId: ID!
}

type UpdateHowCauseEffectPayload {
  essay: Essay!
}

input UpdateLessonInput {
  afterActivity: TextSectionProtocolsInput!
  assignedDate: Date!
  assignedMarkingPeriod: MarkingPeriodEnum!
  assignedSectionIdList: [ID!]!
  assignedSections: LessonTextSectionsInput!
  beforeActivity: TextSectionProtocolsInput!
  duringActivities: [TextSectionProtocolsInput!]!
  essentialQuestion: String!
  inUnit: ID!
  lessonName: String!
  linkedCourseIds: [ID!]!
  pageNumbers: PageNumbersInput!
  questionList: [TextSectionQuestionsInput!]!
  vocabList: [TextSectionVocabInput!]!
}

type UpdateLessonPayload {
  lessons: [Lesson!]!
}

input UpdateProblemSolutionInput {
  essayId: ID!
  problem: String!
  reasonForProblem: String!
  solvedBy: String!
  whySolutionSolved: String!
}

type UpdateProblemSolutionPayload {
  essay: Essay!
}

input UpdateResponsibilityPointsInput {
  markingPeriod: MarkingPeriodEnum
  points: Int!
  studentId: ID!
}

type UpdateResponsibilityPointsPayload {
  responsibilityPoints: ResponsibilityPoints!
}

input UpdateRubricEntryInput {
  entry: String!
  rubricCategories: [WritingLevelEnum!]!
  rubricEntryId: ID!
  rubricSection: RubricSectionEnum!
  score: Int!
}

type UpdateRubricEntryPayload {
  rubricEntry: RubricEntry!
}

input UpdateTextSectionInput {
  _id: ID!
  fromChapterId: String!
  hasProtocols: [TextSectionProtocolsInput!]!
  hasQuestions: [TextSectionQuestionsInput!]!
  hasVocab: [TextSectionVocabInput!]!
  header: String!
  pageNumbers: PageNumbersInput!
}

type UpdateTextSectionPayload {
  textSection: TextSection!
}

type UpdateVocabPayload {
  textSection: TextSection!
}

input UpdateWhyCauseEffectInput {
  essayId: ID!
  proximateCause: String!
  ultimateCause: String!
}

type UpdateWhyCauseEffectPayload {
  essay: Essay!
}

input UpdateWorkingDraftInput {
  _id: ID!
  updatedDraft: JSON!
}

type UpdateWorkingDraftPayload {
  essay: Essay!
}

interface User {
  _id: ID
  email: String
  firstName: String!
  lastName: String!
  password: String!
  userName: String!
}

type WhyCauseEffectAnswerType {
  proximateCause: String!
  ultimateCause: String!
}

type WhyCauseEffectMetrics {
  levelPoints: Int!
  whyCauseEffectLevel: WritingLevelEnum!
}

type WorkingDraft {
  draft: JSON!
  organizer: Organizers
}

enum WritingLevelEnum {
  ACADEMIC
  ADVANCED
  DEVELOPING
}

type WritingMetrics implements ProgressMetrics {
  _id: ID
  howCauseEffectMetrics: HowCauseEffectMetrics!
  howProblemSolutionMetrics: HowProblemSolutionMetrics!
  overallWritingMetric: OverallWritingMetric!
  student: Student!
  whyCauseEffectMetrics: WhyCauseEffectMetrics!
}
